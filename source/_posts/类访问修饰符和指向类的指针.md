---
title: 类访问修饰符和指向类的指针
tags: [大学作业, C++]
categories: [大学作业, C++]
keywords: [大学作业, C++]
top_img: >-
  https://adguycn990-typoraimage.oss-cn-hangzhou.aliyuncs.com/202211232358703.webp
highlight_shrink: false
katex: false
copyright_author: adguy
copyright_author_href: 'https://adguy.top'
copyright_url: 'https://adguy.top/adguy/a7534cc2.html'
copyright_info: 此文章版权归金晖のBlog所有，如有转载，请注明来自原作者
abbrlink: a7534cc2
date: 2022-12-02 10:30:58
description:
post_copyright:
---

## 类访问修饰符

数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 **public、private、protected** 来指定的。关键字 **public、private、protected** 称为访问修饰符。

### public

**公有**成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值

### private

**私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。

默认情况下，类的所有成员都是私有的。

### procted

protected（受保护）成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。

### 继承中的特点

有 public, protected, private 三种继承方式，它们相应地改变了基类成员的访问属性。

- 1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private
- 2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private
- 3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private

但无论哪种继承方式，上面两点都没有改变：

- 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；
- 2.protected 成员可以被派生类访问。

| 继承方式       | 基类的 public 成员  | 基类的 protected 成员 | 基类的 private 成员 | 继承引起的访问控制关系变化概括         |
| :------------- | :------------------ | :-------------------- | :------------------ | :------------------------------------- |
| public 继承    | 仍为 public 成员    | 仍为 protected 成员   | 不可见              | 基类的非私有成员在子类的访问属性不变   |
| protected 继承 | 变为 protected 成员 | 变为 protected 成员   | 不可见              | 基类的非私有成员都为子类的保护成员     |
| private 继承   | 变为 private 成员   | 变为 private 成员     | 不可见              | 基类中的非私有成员都称为子类的私有成员 |

## 指向类的指针

一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 **->**，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。

### 示例

```cpp
#include <iostream>

using namespace std;

class Box {
public:
    // 构造函数定义
    Box(double l = 2.0, double b = 2.0, double h = 2.0) {
        cout << "Constructor called." << endl;
        length = l;
        breadth = b;
        height = h;
    }
    double Volume() {
        return length * breadth * height;
    }
private:
    double length;     // Length of a box
    double breadth;    // Breadth of a box
    double height;     // Height of a box
};

int main(void) {
    Box Box1(3.3, 1.2, 1.5);    // Declare box1
    Box Box2(8.5, 6.0, 2.0);    // Declare box2
    Box *ptrBox;                // Declare pointer to a class.
    // 保存第一个对象的地址
    ptrBox = &Box1;
    // 现在尝试使用成员访问运算符来访问成员
    cout << "Volume of Box1: " << ptrBox->Volume() << endl;
    // 保存第二个对象的地址
    ptrBox = &Box2;
    // 现在尝试使用成员访问运算符来访问成员
    cout << "Volume of Box2: " << ptrBox->Volume() << endl;
    return 0;
}

/*
===============
Constructor called.
Constructor called.
Volume of Box1: 5.94
Volume of Box2: 102
===============
*/
```

