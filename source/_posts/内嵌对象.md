---
title: 内嵌对象
tags:
  - 大学作业
  - C++
categories:
  - 大学作业
  - C++
keywords:
  - 大学作业
  - C++
top_img: >-
  https://adguycn990-typoraimage.oss-cn-hangzhou.aliyuncs.com/202211232358703.webp
highlight_shrink: false
katex: false
copyright_author: adguy的某个队友
copyright_author_href: 'https://adguy.top'
copyright_url: 'https://adguy.top/adguy/bae01d16.html'
copyright_info: 此文章版权归金晖のBlog所有，如有转载，请注明来自原作者
abbrlink: bae01d16
date: 2022-12-02 12:00:08
description:
post_copyright:
---

{% tip %}非常感激我队友大爹给我的复习资料{% endtip %}

类的成员变量为用户自定义的类型时，这些成员变量称为内嵌对象。对象嵌入称做"has-a"关系，就本例来说” World has a Master"。

## 示例

```cpp
/*
类的成员变量为用户自定义的类型时，这些成员变量称为内嵌对象。对象嵌入称做"has-a"关系，就本例来说” World has a Master"。
*/

#include <iostream>
using namespace std;

class Master{
    private:
        int _identifier;
    public:
        Master(int id) : _identifier(id){
            cout << "Master for " << _identifier << " created" << endl;
        }
        ~Master(){
            cout << "Master for " << _identifier << " destroyed" << endl;
        }
};

class World{
    private:
        const int _identifier;
        const Master _master;
    public:
        World(int id) : _identifier(id), _master(_identifier){
            cout << "hello world " << _identifier << endl;
        }
        ~World(){
            cout << "goodbye world" << _identifier << endl;
        }
};

World theWorld(1);

int main(void){
    World smallWorld(2);
    return 0;
}

/*
=========================
Master for 1 created  
hello world 1
Master for 2 created  
hello world 2
goodbye world2        
Master for 2 destroyed
goodbye world1
Master for 1 destroyed
=========================
*/
```

单单看这个例子就没什么好说的，但是这里涉及到了两个知识点。

## 初始化列表

可以看到在Wrold类中用了初始化列表的方法对Master类进行初始化。这是因为必须使用初始化列表进行构造。

- 成员类型是**没有默认构造函数的类**。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。
- **const 成员**或**引用类型**的成员。因为 const 对象或引用类型只能初始化，不能对他们赋值。

第一，成员变量_master首先是用了const进行修饰；其次，Master类并没有提供默认构造函数，只提供了带参数的构造方式。所以只能用初始化列表的方式来初始化。

## 析构函数与析构函数顺序

对象在创建时构造函数的调用顺序

1. 调用父类的构造函数
2. 调用成员变量的构造函数
3. 调用类自身的构造函数

析构函数的调用顺序与构造函数相反

1. 执行自身的析构函数
2. 执行成员变量的析构函数
3. 执行父类的析构函数

在本示例中，Master是World的成员变量。所以先构造Master在构造World；同理，析构时先析构World再析构Master。
