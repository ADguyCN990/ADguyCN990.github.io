---
title: 作业1
tags:
  - 大学作业
  - C++
categories:
  - 大学作业
  - C++
keywords:
  - 大学作业
  - C++
  - 构造器
  - Class
  - 面向对象
  - 类
top_img: >-
  https://adguycn990-typoraimage.oss-cn-hangzhou.aliyuncs.com/202211232358703.webp
highlight_shrink: false
katex: false
copyright_author: adguy
copyright_author_href: 'https://adguy.top'
copyright_url: 'https://adguy.top/adguy/90018cad.html'
copyright_info: 此文章版权归金晖のBlog所有，如有转载，请注明来自原作者
abbrlink: 90018cad
date: 2022-11-25 14:50:32
description:
post_copyright:
---

## P33 1.5

编写一个程序，能够询问用户的姓名，并读取用户所输入的内容。请确保用户输入的名称长度大于两个字符。如果用户的确输入了有效名称，就响应一些信息。请以两种方式实现：第一种使用C-style字符串，第二种使用string对象。

```cpp
#include "bits/stdc++.h"
using namespace std;
set<string> v1;
set<char *> v2;

int query1() {
    char s[105];
    scanf("%s", s);
    if (strlen(s) <= 2) {
        return -1;
    }
    if (v2.count(s)) {
        return 1;
    }
    else {
        return 0;
    }
}

int query2() {
    string s;
    cin >> s;
    if (s.size() <= 2) {
        return -1;
    }
    if (v1.count(s)) {
        return 1;
    }
    else {
        return 0;
    }
}

int main() {
    //load names in v1 and v2
    int ans;
    //ans = query1() or ans = query2();
    if (ans == 0) {
        cout << "do not find this name" << endl;
    }
    else if (ans == -1) {
        cout << "invalid format" << endl;
    }
    else if (ans == 1) {
        cout << "find this name!" << endl;
    }
    return 0;
}
```

## P33 1.6

编写一个程序，从标准输入设备读取一串整数，并将读入的整数依次放到array及vector，然后遍历这两种容器，求取数值总和。将总和及平均值输出至标准输出设备。

```cpp
#include "bits/stdc++.h"
using namespace std;
#define MAXN 10
int a[MAXN + 1];
vector<int> b(MAXN + 1, 0);

int main() {
    for (int i = 0; i < MAXN; i++) {
        cin >> b[i];
        a[i] = b[i];
    }
    int sum1 = 0, sum2 = 0, ave1 = 0, ave2 = 0;
    for (int i = 0; i < MAXN; i++) {
        sum1 += a[i];
        sum2 += b[i];
    }
    ave1 = sum1 / 10, ave2 = sum2 / 10;
    cout << sum1 << " " << sum2 << " " << ave1 << " " << ave2 << endl;
    return 0;
}
```

## P134 4.4

一份“用户概况记录（user profile）”内包含一下数据：登录记录、实际姓名、登入次数、猜过次数、猜对次数、等级：包括初级、中级、高级、专家，以及猜对百分比（可实时计算获得，或将其值储存起来备用）。请写出一个名为UserProfile的class，提供以下操作：输入、输出、相等测试、不等测试。其constructor必须能够处理默认的用户等级、默认的登录名称（"guest"）。对于同样名为guest的多个用户，你如何保证每个guest有他自己独有的登录会话（login session），不会和其他人混淆？

- 依据面向对象的编程思维求解，设置每个人的个人信息为private。

```cpp
#include "bits/stdc++.h"
using namespace std;

class UserProfile {
public:
    //定义枚举类型ulevel，枚举元素作为常量，是有值的，分别为0,1,2,3,4.....
    enum ulevel {
        Beginner, Intermediate, Advanced, Guru
    };
    UserProfile(string login, ulevel = Beginner);
    UserProfile();
    //以下函数用来读取数据
    string login() const { return _login; }
    int login_count() const { return _login_count; }
    int guess_count() const { return _guess_count; }
    int guess_correct() const { return _guess_correct; }
    string level() const;
    double guess_average() const;
    //以下函数用来写入数据
    void reset_login(const string &val) { _login = val; }
    void reset_level(const string &level);
    void reset_login_count(int val) { _login_count = val; }
    void reset_guess_count(int val) { _guess_count = val; }
    void reset_guess_correct(int val) { _guess_correct = val; }
    void bump_login_count(int cnt = 1) { _login_count += cnt; }
    void bump_guess_count(int cnt = 1) { _guess_count += cnt; }
    void bump_guess_correct(int cnt = 1) { _guess_correct += cnt; }
private:
    string _login;
    int _login_count;
    int _guess_count;
    int _guess_correct;
    ulevel _user_level;
    static map<string, ulevel> _level_map;
    static void init_level_map();
    //static string guest_login();
};

//开始定义函数

//定义猜对百分比函数
inline double UserProfile::guess_average() const {
    return _guess_count ? double(_guess_correct) / double(_guess_count) * 100 : 0.0;
}

//"有参无默认值"初始化，用于有名字和等级的客户
inline UserProfile::UserProfile(string login, ulevel level)
        : _login(login), _user_level(level), _login_count(1), _guess_count(0), _guess_correct(0) {}

//默认构造函数初始化，用于默认的guest用户初始化
//guest的等级默认设定为Beginner

inline UserProfile::UserProfile()
        : _login("guest"), _user_level(Beginner), _login_count(1), _guess_count(0), _guess_correct(0) {
    static int id = 0;
    char buffer[16];
    _itoa_s(id++, buffer, 10);//C语言中的函数，将整型值转换为字符串
    _login += buffer;
}
//输出流重载
ostream &operator<<(ostream &os, const UserProfile &rhs) {// 输出格式：qing Beginner 12 100 10 10%
    os << rhs.login() << ' '
       << rhs.level() << ' '
       << rhs.login_count() << ' '
       << rhs.guess_count() << ' '
       << rhs.guess_correct() << ' '
       << rhs.guess_average() << '%' << endl;
    return os;  //不要忘了要返回输出量os
}

//静态static数据成员初始化
map<string, UserProfile::ulevel> UserProfile::_level_map;

void UserProfile::init_level_map() {
    _level_map["Beginner"] = Beginner;          //等价于dic={"Beginner":0,"Intermediate":1,"Advanced":2,"Guru":3}
    _level_map["Intermediate"] = Intermediate;
    _level_map["Advanced"] = Advanced;
    _level_map["Guru"] = Guru;
}

//定义level函数,返回的是等级的字符串string形式。
inline string UserProfile::level() const {
    static string _level_table[] = {"Beginner", "Intermediate", "Advanced", "Guru"};
    return _level_table[_user_level]; //枚举元素作为常量，是有值的，分别为0, 1, 2, 3, 4.....
}

//定义reset_level函数，得到_user_level参数
inline void UserProfile::reset_level(const string &level) {
    map<string, ulevel>::iterator it;
    if (_level_map.empty())
        init_level_map();
    //确保level的确代表一个可识别的用户等级
    _user_level = ((it = _level_map.find(level)) != _level_map.end())
                  ? it->second : Beginner;
}


//输入流重载
istream &operator>>(istream &is, UserProfile &rhs) {
    string login, level;
    is >> login >> level;
    int lcount, gcount, gcorrect;
    is >> lcount >> gcount >> gcorrect;
    rhs.reset_login(login);
    rhs.reset_level(level);
    rhs.reset_login_count(lcount);
    rhs.reset_guess_count(gcount);
    rhs.reset_guess_correct(gcorrect);
    return is;
}
```

## P134 4.5

请提供一个default constructor, 可选择性地接受16个数据值。再提供一个constructor，可接受一个拥有16个元素的数组。你不需要为此class提供copy constructor、copy assignment operator、destructor。

```cpp
#include "bits/stdc++.h"
using namespace std;
int b[16];
class Matrix {
    typedef int Mat_ele;
public:
    Matrix(const Mat_ele *a);
    Matrix(Mat_ele a1, Mat_ele a2, Mat_ele a3, Mat_ele a4,
           Mat_ele a5, Mat_ele a6, Mat_ele a7, Mat_ele a8,
           Mat_ele a9, Mat_ele a10, Mat_ele a11, Mat_ele a12,
           Mat_ele a13, Mat_ele a14, Mat_ele a15, Mat_ele a16
    );
private:
    Mat_ele value[4][4]{};
};

Matrix::Matrix(const Mat_ele *a) {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            value[i][j] = *(a + i * 4 + j);
        }
    }
}

Matrix::Matrix(Mat_ele a1, Mat_ele a2, Mat_ele a3, Mat_ele a4,
               Mat_ele a5, Mat_ele a6, Mat_ele a7, Mat_ele a8,
               Mat_ele a9, Mat_ele a10, Mat_ele a11, Mat_ele a12,
               Mat_ele a13, Mat_ele a14, Mat_ele a15, Mat_ele a16) {
    value[0][0] = a1, value[0][1] = a2, value[0][2] = a3, value[0][3] = a4;
    value[1][0] = a5, value[1][1] = a6, value[1][2] = a7, value[1][3] = a8;
    value[2][0] = a9, value[2][1] = a10, value[2][2] = a11, value[2][3] = a12;
    value[3][0] = a13, value[3][1] = a14, value[3][2] = a15, value[3][3] = a16;

}

int main() {
    Matrix c(b);
    //Matrix d(1, 2, 3, ..., 14, 15, 16);
    return 0;
}
```

