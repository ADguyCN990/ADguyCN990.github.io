---
title: 项目概述和环境配置
tags:
  - Springboot
categories:
  - 工程
  - Springboot
  - kob
keywords:
  - Springboot
top_img: >-
  https://adguycn990-typoraimage.oss-cn-hangzhou.aliyuncs.com/202211232358703.webp
highlight_shrink: false
katex: false
copyright_author: adguy
copyright_author_href: 'https://adguy.top'
copyright_url: 'https://adguy.top/adguy/e4eabac6.html'
copyright_info: 此文章版权归金晖のBlog所有，如有转载，请注明来自原作者
abbrlink: e4eabac6
date: 2022-12-19 19:48:13
description:
post_copyright:
---

## 项目设计

- 项目包含的模块
  - PK 模块：匹配界面（微服务）、实况直播界面（WebSocket 协议）
  - 对局列表模块：对局列表界面、对局录像界面
  - 排行榜模块：Bot 排行榜界面
  - 用户中心模块：注册界面、登录界面、我的 Bot 界面、每个 Bot 的详情界面
- 前后端分离模式
  - SpringBoot 实现后端
  - Vue3 实现 Web 端和 AcApp 端

前端使用`Vscode`，后端使用`IDEA`。

## 解决前端跨域问题

在后端文件的根目录`src/main/java/com/example/backend`下，新建`config`文件夹，在该文件夹内，新建`CorsConfig`文件并写入以下代码：

```java
package com.example.backend.config;

import org.springframework.context.annotation.Configuration;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Configuration
public class CorsConfig implements Filter {
    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
        HttpServletResponse response = (HttpServletResponse) res;
        HttpServletRequest request = (HttpServletRequest) req;

        String origin = request.getHeader("Origin");
        if(origin!=null) {
            response.setHeader("Access-Control-Allow-Origin", origin);
        }

        String headers = request.getHeader("Access-Control-Request-Headers");
        if(headers!=null) {
            response.setHeader("Access-Control-Allow-Headers", headers);
            response.setHeader("Access-Control-Expose-Headers", headers);
        }

        response.setHeader("Access-Control-Allow-Methods", "*");
        response.setHeader("Access-Control-Max-Age", "3600");
        response.setHeader("Access-Control-Allow-Credentials", "true");

        chain.doFilter(request, response);
    }

    @Override
    public void init(FilterConfig filterConfig) {

    }

    @Override
    public void destroy() {
    }
}


```

## 基本的前后端交互

后端理解为一个函数库，存放各种各样的函数。把这些函数都放在`controller`目录下。

前端利用`ajax`即可调用后端的函数，以下面代码为例。

### 后端函数

```java
package com.example.backend.controller.pk;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/pk/")
public class BotInfoController {
    @RequestMapping("getbotinfo/")
    public String getBotInfo() {
        return "沃斯尼蝶";
    }
}
```

#### 八股

{% note info flat %}

在 SpringMVC 中，控制器 Controller 负责处理由 DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个 Model ，然后再把该 Model 返回给对应的 View 进行展示。

在 SpringMVC 中提供了一个非常简便的定义 Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用 @Controller 标记一个类是 Controller ，然后使用 @RequestMapping 和 @RequestParam 等一些注解用以定义 URL 请求和 Controller 方法之间的映射，这样的 Controller 就能被外界访问到。

此外 Controller 不会直接依赖于 HttpServletRequest 和 HttpServletResponse 等 HttpServlet 对象，它们可以通过 Controller 的方法参数灵活的获取到。

{% endnote %}

`@RestController`和`@RequestMapping`是Springboot中的注解。

- @Controller: 定义一个控制器类。
- 用 @ResponseBody 标记 Controller 类中的方法。把 return 的结果变成 JSON 对象返回。（如果没有这个注解，这个方法只能返回要跳转的路径即跳转的 html/JSP 页面。有这个注解，可以不跳转页面，只返回 JSON 数据）。

- @RestController: 相当于 @Controller+@ResponseBody 两个注解的结合，返回 json 数据不需要在方法前面加 @ResponseBody 注解了，但使用 @RestController 这个注解，就不能返回 jsp,html 页面，视图解析器无法解析 jsp,html 页面。**前后端分离的写法**。

- @RequestMapping: 给出外界访问方法的路径，或者说触发路径 ，触发条件。

### 前端调用

```vue
<template>
  <h1>我的最爱：{{ name }}</h1>
  <router-view/>
</template>

<script>
import $ from 'jquery';
import { ref } from 'vue';


export default {
  setup: () => {
    let name = ref("");

    $.ajax({
      url: "http://127.0.0.1:3000/pk/getbotinfo/",
      type: "get",
      success: resp => {
        name.value = resp;
      }
    })

    return {
      name
    }
  }
}
</script>

<style scoped>
</style>
```

前端调用了一个ajax请求，链接是本地的`pk/gitbotinfo/`。后端依据`@RequestMapping("/pk/")`和`@RequestMapping("getbotinfo/")`定位到了所需的函数，执行该函数并将产生的结果返回给前端。

最终的结果就是这样

![image-20221219201059893](https://adguycn990-typoraimage.oss-cn-hangzhou.aliyuncs.com/202212192015192.png)

