---
title: 类构造函数初始化列表
tags:
  - C++
categories:
  - 大学作业
  - C++
keywords:
  - C++
top_img: >-
  https://adguycn990-typoraimage.oss-cn-hangzhou.aliyuncs.com/202211232358703.webp
highlight_shrink: false
katex: false
copyright_author: adguy的某个队友
copyright_author_href: 'https://adguy.top'
copyright_url: 'https://adguy.top/adguy/c90ecfb8.html'
copyright_info: 此文章版权归金晖のBlog所有，如有转载，请注明来自原作者
abbrlink: c90ecfb8
date: 2022-11-30 23:07:16
description:
post_copyright:
---

{% tip %}非常感激我队友大爹给我的复习资料{% endtip %}

## 定义格式

构造函数初始化列表以冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟着一个放在括号中的初始化式。

```cpp
class Example{
    public:
        int a;
        float b;
        // 构造函数初始化列表
        Example() : a(0), b(8.7) {}
        // 构造函数内部赋值
        // Example() {a = 0; b = 8.7;}
};
```

## 初始化顺序

C++初始化类成员时, 是按照声明的顺序初始化的, 而不是按照出现在初始化列表中的顺序。

以下面的顺序为例：

```cpp
class Test {
public:
    int _a, _b;
    Test(int a, int b) : _b(b), _a(_b) {}
};

cout << tt._a << " " << tt._b << endl; // output: 0 13
```

编译器实际上是先初始化_a，再初始化\_b，因为他们是按照这样的顺序声明的。

结果是先执行`_a = _b`，导致\_a=0。

解决方法：总是按照你希望它们被初始化的顺序声明成员; 或者, 如果决定使用初始化列表, 总是按照它们声明的顺序罗列这些成员。

## 与普通构造函数内部赋值联系（八股）

### 不同点

两个构造函数的结果是相同的。使用初始化列表的构造函数，显式的初始化类的成员；而下面的那个是对类的成员赋值，没有进行显式的初始化。

初始化和赋值对内置类型的成员没有什么大的区别，像上面的任一个构造函数都可以。而对非内置类型成员变量，为了避免两次构造，推荐使用类构造函数初始化列表。

### 必须使用初始化列表的情况

1. 成员类型是没有默认构造函数的类。若没有提供显式初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。
2. const成员或引用类型的成员。因为const对象或引用类型只能初始化，不能对它们赋值。

### 赋值与初始化

数据类型可分为两类：

- 内置数据类型，复合类型(指针,引用) -- 在成员初始化列表和构造函数体内进行, 在性能和结果上都是一样的
- 用户自定义类型(类类型) -- 结果上相同, 但是性能上存在很大差别。因为类类型的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行构造对象工作, 调用构造函数，在进行函数体之后，进行的是对已经构造好的类对象的赋值，又调用一个拷贝赋值操作符才能完成(如果并未提供，则使用编译器提供的默认按成员赋值行为)

## 源码

```cpp
#include <bits/stdc++.h>
using namespace std;

// 构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟着一个放在括号中的初始化式。
class Example{
    public:
        int a;
        float b;
        // 构造函数初始化列表
        Example() : a(0), b(8.7) {}
        // 构造函数内部赋值
        // Example() {a = 0; b = 8.7;}
};

// 注意: C++初始化类成员时, 是按照声明的顺序初始化的, 而不是按照出现在初始化列表中的顺序。
/*
    编译器实际上是先初始化m_x, 然后是m_y。因为他们是按照这样的顺序声明的。结果是m_x将有一个
不可预测的值, my=y。
    解决方法: 总是按照你希望它们被初始化的顺序声明成员; 或者, 如果决定使用初始化列表, 总是
按照它们声明的顺序罗列这些成员。
*/
class Test {
public:
    int _a, _b;
    Test(int a, int b) : _b(b), _a(_b) {}
};

int main(void){
    Example ex;
    cout << ex.a << " " << ex.b << endl;
    Test tt(12, 13);
    cout << tt._a << " " << tt._b << endl; // output: 0 13
    return 0;
}
```

