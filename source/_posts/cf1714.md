---
title: Codeforces 1714E.Add Module 10
tags: [acm, 题解, codeforces]
categories: [acm, 题解]
keywords: [acm, 题解, codeforces, cf1714E, ADD MODULE 10]
top_img: https://adguycn990-typoraimage.oss-cn-hangzhou.aliyuncs.com/202211232358703.webp
highlight_shrink: false
katex: true
copyright_author: adguy
copyright_author_href: 'https://adguycn990.github.io'
copyright_url: 'https://adguycn990.github.io/adguy/2fb67de5.html'
copyright_info: 此文章版权归金晖の博客所有，如有转载，请註明来自原作者
abbrlink: 2fb67de5
date: 2022-11-22 18:07:59
post_copyright:
---

[原题链接](https://codeforces.com/contest/1714/problem/E)

**翻译：**

给出一个长度为n的数组，对每个元素a[i],可以执行  a[i] = a[i] + a[i] mod 10 无限次。问可不可以构造出一个所有元素相等的数组。

**思路：**

找规律即可。手算模拟几次发现，除了末尾为5或0的数字需要特判。其他数字在模20后可以统统分成两组，两个集合是对立的，根据这个去check即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MAXN 200005
#define MAXM 200005
typedef pair<int, int> pii;
#define INF 0x3f3f3f3f
#define rep(i, x, y) for (int i = x; i <= y; i++)
#define per(i, x, y) for(int i = x; i >= y; i--)
#define pb emplace_back
ll read() {
    ll x=0,f=1;char ch;
    do{ch=getchar();if(ch=='-') f=-1;} while(ch<'0'||ch>'9');
    do{x=x*10+ch-48;ch=getchar();} while(ch>='0'&&ch<='9');
    return x*f;
}
int n;
int a[MAXN];
bool vis[25];

void init() {
    for (int i = 0; i <= 20; i++) {
        vis[i] = false;
    }
}

bool check() {
    map<int, int> cnt;
    for (int i = 1; i <= n; i++) {
        if (a[i] % 10 != 0 && a[i] % 10 != 5) {
            return false;
        }
    }
    sort(a + 1, a + 1 + n);
    if (a[n] - a[1] == 5 && a[1] % 10 == 5 || a[1] == a[n]) {
        return true;
    }
    return false;
}

void solve() {
    n = read();
    init();
    bool check_flag = false;
    for (int i = 1; i <= n; i++) {
        a[i] = read();
        if (a[i] % 10 == 5 || a[i] % 10 == 0) {
            check_flag = true;
        }
        vis[a[i] % 20] = true;
    }
    if (check_flag) {
        check_flag = check();
        if (check_flag) {
            puts("YES");
        }
        else {
            puts("NO");
        }
        return;
    }
    bool group1 = vis[1] || vis[2] || vis[4] || vis[8] || vis[16] || vis[13] || vis[17] || vis[19];
    bool group2 = vis[3] || vis[7] || vis[9] || vis[11] || vis[6] || vis[12] || vis[14] || vis[18];
    if (group1 && group2) {
        puts("NO");
    }
    else {
        puts("YES");
    }
}

int main() {
    int T;
    T = read();
    for (int i = 1; i <= T; i++) {
        solve();
    }

    return 0;
}
```

