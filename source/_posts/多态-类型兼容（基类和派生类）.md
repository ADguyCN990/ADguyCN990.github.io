---
title: 多态-类型兼容（基类和派生类）
tags: [大学作业, C++]
categories: [大学作业, C++]
keywords: [大学作业, C++]
top_img: >-
  https://adguycn990-typoraimage.oss-cn-hangzhou.aliyuncs.com/202211232358703.webp
highlight_shrink: false
katex: false
copyright_author: adguy的某个队友
copyright_author_href: 'https://adguy.top'
copyright_url: 'https://adguy.top/adguy/ee2b8005.html'
copyright_info: 此文章版权归金晖のBlog所有，如有转载，请注明来自原作者
abbrlink: ee2b8005
date: 2022-12-07 08:47:07
description:
post_copyright:
---

{% tip %} 非常感激我队友大爹提供的复习资料 {% endtip %}

## 定义

类型兼容规则是指在需要基类对象的任何地方, 都可以使用公有派生类的对象来替代。

类型兼容规则中所指的替代包括以下的情况:

- 派生类的对象可以隐含转换为基类对象;
- 派生类的对象可以初始化基类的引用;
- 派生类的指针可以隐含转换为基类的指针;

在替代之后, 派生类对象就可以作为基类的对象使用, 但只能使用从基类继承的成员。

可以说, 类型兼容原则是多态性的重要基础之一。

## 示例1

```cpp
class B{};
class D : public B {};
B b, *pb;
D d;
```

此时：

- 派生类对象可以隐含转换为基类对象, 即用派生类对象中从基类继承来的成员逐个赋值给基类对象的成员; `b=d;`
- 派生类的对象也可以初始化基类对象的引用; `B& rb = d;`
- 派生类对象的地址也可以隐含转换为指向基类的指针; `pb = &d;`

## 示例2

```cpp
#include <iostream>
using namespace std;

class Base1{
    protected:
        int _val;
    public:
        Base1(int val) : _val(val) {}
        void display() const { cout << "Base1 val: " << _val << endl; }
};

class Base2 : public Base1{
    public:
        Base2(int val) : Base1(val) {}
        void display() const { cout << "Base2 val: " << _val << endl; }
};

class Derived : public Base2{
    public:
        Derived(int val) : Base2(val) {}
        void display() const { cout << "Derived val: " << _val << endl; }
};

void func(Base1 * ptr){ // 参数为指向基类对象的指针
    ptr->display();     // 对象名->成员名
}

int main(void){
    Base1 b1(2);
    Base2 b2(3);
    Derived d(4);

    func(&b1);
    func(&b2);
    func(&d);
    b1.display();
    b2.display();
    d.display();

    return 0;
}
```

